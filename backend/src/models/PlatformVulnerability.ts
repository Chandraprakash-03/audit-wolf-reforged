import { DatabaseService } from "../services/database";
import { PlatformVulnerability as PlatformVulnerabilityType } from "../types/database";

export class PlatformVulnerabilityModel {
	public id: string;
	public audit_id?: string;
	public multi_chain_audit_id?: string;
	public platform: string;
	public vulnerability_type: string;
	public severity: "critical" | "high" | "medium" | "low" | "informational";
	public title: string;
	public description: string;
	public location: Record<string, any>;
	public recommendation: string;
	public platform_specific_data?: Record<string, any>;
	public confidence: number;
	public source: "static" | "ai" | "combined";
	public created_at: Date;

	constructor(data: PlatformVulnerabilityType) {
		this.id = data.id;
		this.audit_id = data.audit_id;
		this.multi_chain_audit_id = data.multi_chain_audit_id;
		this.platform = data.platform;
		this.vulnerability_type = data.vulnerability_type;
		this.severity = data.severity;
		this.title = data.title;
		this.description = data.description;
		this.location = data.location;
		this.recommendation = data.recommendation;
		this.platform_specific_data = data.platform_specific_data;
		this.confidence = data.confidence;
		this.source = data.source;
		this.created_at = data.created_at;
	}

	static async create(vulnData: {
		audit_id?: string;
		multi_chain_audit_id?: string;
		platform: string;
		vulnerability_type: string;
		severity: "critical" | "high" | "medium" | "low" | "informational";
		title: string;
		description: string;
		location: Record<string, any>;
		recommendation: string;
		platform_specific_data?: Record<string, any>;
		confidence: number;
		source: "static" | "ai" | "combined";
	}): Promise<PlatformVulnerabilityModel | null> {
		// Validate that at least one audit reference exists
		if (!vulnData.audit_id && !vulnData.multi_chain_audit_id) {
			throw new Error(
				"Either audit_id or multi_chain_audit_id must be provided"
			);
		}

		const vulnerability = await DatabaseService.createPlatformVulnerability(
			vulnData
		);
		return vulnerability ? new PlatformVulnerabilityModel(vulnerability) : null;
	}

	static async findByAuditId(
		auditId: string
	): Promise<PlatformVulnerabilityModel[]> {
		const vulnerabilities =
			await DatabaseService.getPlatformVulnerabilitiesByAuditId(auditId);
		return vulnerabilities.map(
			(vuln: PlatformVulnerabilityType) => new PlatformVulnerabilityModel(vuln)
		);
	}

	static async findByMultiChainAuditId(
		multiChainAuditId: string
	): Promise<PlatformVulnerabilityModel[]> {
		const vulnerabilities =
			await DatabaseService.getPlatformVulnerabilitiesByMultiChainAuditId(
				multiChainAuditId
			);
		return vulnerabilities.map(
			(vuln: PlatformVulnerabilityType) => new PlatformVulnerabilityModel(vuln)
		);
	}

	static async findByPlatform(
		platform: string
	): Promise<PlatformVulnerabilityModel[]> {
		const vulnerabilities =
			await DatabaseService.getPlatformVulnerabilitiesByPlatform(platform);
		return vulnerabilities.map(
			(vuln: PlatformVulnerabilityType) => new PlatformVulnerabilityModel(vuln)
		);
	}

	static async createBatch(
		vulnerabilities: Array<{
			audit_id?: string;
			multi_chain_audit_id?: string;
			platform: string;
			vulnerability_type: string;
			severity: "critical" | "high" | "medium" | "low" | "informational";
			title: string;
			description: string;
			location: Record<string, any>;
			recommendation: string;
			platform_specific_data?: Record<string, any>;
			confidence: number;
			source: "static" | "ai" | "combined";
		}>
	): Promise<PlatformVulnerabilityModel[]> {
		const created: PlatformVulnerabilityModel[] = [];

		for (const vulnData of vulnerabilities) {
			try {
				const vulnerability = await PlatformVulnerabilityModel.create(vulnData);
				if (vulnerability) {
					created.push(vulnerability);
				}
			} catch (error) {
				console.error("Failed to create platform vulnerability:", error);
			}
		}

		return created;
	}

	isCritical(): boolean {
		return this.severity === "critical";
	}

	isHigh(): boolean {
		return this.severity === "high";
	}

	isMedium(): boolean {
		return this.severity === "medium";
	}

	isLow(): boolean {
		return this.severity === "low";
	}

	isInformational(): boolean {
		return this.severity === "informational";
	}

	isHighConfidence(): boolean {
		return this.confidence >= 0.8;
	}

	isMediumConfidence(): boolean {
		return this.confidence >= 0.5 && this.confidence < 0.8;
	}

	isLowConfidence(): boolean {
		return this.confidence < 0.5;
	}

	getSeverityScore(): number {
		const severityScores = {
			critical: 10,
			high: 7,
			medium: 5,
			low: 3,
			informational: 1,
		};
		return severityScores[this.severity];
	}

	getRiskScore(): number {
		return this.getSeverityScore() * this.confidence;
	}

	getLocationString(): string {
		if (this.location.file && this.location.line) {
			return `${this.location.file}:${this.location.line}${
				this.location.column ? `:${this.location.column}` : ""
			}`;
		}
		return "Unknown location";
	}

	getPlatformSpecificInfo(key: string): any {
		return this.platform_specific_data?.[key];
	}

	hasPlatformSpecificData(): boolean {
		return (
			this.platform_specific_data !== undefined &&
			Object.keys(this.platform_specific_data).length > 0
		);
	}

	// Platform-specific helper methods
	isSolanaVulnerability(): boolean {
		return this.platform === "solana";
	}

	isEthereumVulnerability(): boolean {
		return (
			this.platform === "ethereum" ||
			this.platform === "binance-smart-chain" ||
			this.platform === "polygon"
		);
	}

	isCardanoVulnerability(): boolean {
		return this.platform === "cardano";
	}

	isMoveVulnerability(): boolean {
		return this.platform === "aptos" || this.platform === "sui";
	}

	static groupBySeverity(
		vulnerabilities: PlatformVulnerabilityModel[]
	): Record<string, PlatformVulnerabilityModel[]> {
		return vulnerabilities.reduce((groups, vuln) => {
			const severity = vuln.severity;
			if (!groups[severity]) {
				groups[severity] = [];
			}
			groups[severity].push(vuln);
			return groups;
		}, {} as Record<string, PlatformVulnerabilityModel[]>);
	}

	static groupByPlatform(
		vulnerabilities: PlatformVulnerabilityModel[]
	): Record<string, PlatformVulnerabilityModel[]> {
		return vulnerabilities.reduce((groups, vuln) => {
			const platform = vuln.platform;
			if (!groups[platform]) {
				groups[platform] = [];
			}
			groups[platform].push(vuln);
			return groups;
		}, {} as Record<string, PlatformVulnerabilityModel[]>);
	}

	static groupByType(
		vulnerabilities: PlatformVulnerabilityModel[]
	): Record<string, PlatformVulnerabilityModel[]> {
		return vulnerabilities.reduce((groups, vuln) => {
			const type = vuln.vulnerability_type;
			if (!groups[type]) {
				groups[type] = [];
			}
			groups[type].push(vuln);
			return groups;
		}, {} as Record<string, PlatformVulnerabilityModel[]>);
	}

	static sortBySeverity(
		vulnerabilities: PlatformVulnerabilityModel[]
	): PlatformVulnerabilityModel[] {
		const severityOrder = {
			critical: 0,
			high: 1,
			medium: 2,
			low: 3,
			informational: 4,
		};

		return vulnerabilities.sort((a, b) => {
			const severityDiff =
				severityOrder[a.severity] - severityOrder[b.severity];
			if (severityDiff !== 0) {
				return severityDiff;
			}
			// If same severity, sort by confidence (higher first)
			return b.confidence - a.confidence;
		});
	}

	toJSON() {
		return {
			id: this.id,
			audit_id: this.audit_id,
			multi_chain_audit_id: this.multi_chain_audit_id,
			platform: this.platform,
			vulnerability_type: this.vulnerability_type,
			severity: this.severity,
			title: this.title,
			description: this.description,
			location: this.location,
			recommendation: this.recommendation,
			platform_specific_data: this.platform_specific_data,
			confidence: this.confidence,
			source: this.source,
			created_at: this.created_at,
		};
	}
}
