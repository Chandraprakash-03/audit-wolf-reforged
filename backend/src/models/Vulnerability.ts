import { DatabaseService } from "../services/database";
import {
	Vulnerability as VulnerabilityType,
	CodeLocation,
} from "../types/database";

export class VulnerabilityModel {
	public id: string;
	public audit_id: string;
	public type:
		| "reentrancy"
		| "overflow"
		| "access_control"
		| "gas_optimization"
		| "best_practice"
		| "security";
	public severity: "critical" | "high" | "medium" | "low" | "informational";
	public title: string;
	public description: string;
	public location: CodeLocation;
	public recommendation: string;
	public confidence: number;
	public source: "static" | "ai" | "combined";
	public created_at: Date;

	constructor(data: VulnerabilityType) {
		this.id = data.id;
		this.audit_id = data.audit_id;
		this.type = data.type;
		this.severity = data.severity;
		this.title = data.title;
		this.description = data.description;
		this.location = data.location;
		this.recommendation = data.recommendation;
		this.confidence = data.confidence;
		this.source = data.source;
		this.created_at = data.created_at;
	}

	static async create(vulnData: {
		audit_id: string;
		type:
			| "reentrancy"
			| "overflow"
			| "access_control"
			| "gas_optimization"
			| "best_practice"
			| "security";
		severity: "critical" | "high" | "medium" | "low" | "informational";
		title: string;
		description: string;
		location: CodeLocation;
		recommendation: string;
		confidence: number;
		source: "static" | "ai" | "combined";
	}): Promise<VulnerabilityModel | null> {
		const vulnerability = await DatabaseService.createVulnerability(vulnData);
		return vulnerability ? new VulnerabilityModel(vulnerability) : null;
	}

	static async findByAuditId(auditId: string): Promise<VulnerabilityModel[]> {
		const vulnerabilities = await DatabaseService.getVulnerabilitiesByAuditId(
			auditId
		);
		return vulnerabilities.map((vuln) => new VulnerabilityModel(vuln));
	}

	static async createBatch(
		vulnerabilities: Array<{
			audit_id: string;
			type:
				| "reentrancy"
				| "overflow"
				| "access_control"
				| "gas_optimization"
				| "best_practice"
				| "security";
			severity: "critical" | "high" | "medium" | "low" | "informational";
			title: string;
			description: string;
			location: CodeLocation;
			recommendation: string;
			confidence: number;
			source: "static" | "ai" | "combined";
		}>
	): Promise<VulnerabilityModel[]> {
		const created: VulnerabilityModel[] = [];

		for (const vulnData of vulnerabilities) {
			const vulnerability = await VulnerabilityModel.create(vulnData);
			if (vulnerability) {
				created.push(vulnerability);
			}
		}

		return created;
	}

	isCritical(): boolean {
		return this.severity === "critical";
	}

	isHigh(): boolean {
		return this.severity === "high";
	}

	isMedium(): boolean {
		return this.severity === "medium";
	}

	isLow(): boolean {
		return this.severity === "low";
	}

	isInformational(): boolean {
		return this.severity === "informational";
	}

	isHighConfidence(): boolean {
		return this.confidence >= 0.8;
	}

	isMediumConfidence(): boolean {
		return this.confidence >= 0.5 && this.confidence < 0.8;
	}

	isLowConfidence(): boolean {
		return this.confidence < 0.5;
	}

	getSeverityScore(): number {
		const severityScores = {
			critical: 10,
			high: 7,
			medium: 5,
			low: 3,
			informational: 1,
		};
		return severityScores[this.severity];
	}

	getRiskScore(): number {
		return this.getSeverityScore() * this.confidence;
	}

	getLocationString(): string {
		return `${this.location.file}:${this.location.line}:${this.location.column}`;
	}

	static groupBySeverity(
		vulnerabilities: VulnerabilityModel[]
	): Record<string, VulnerabilityModel[]> {
		return vulnerabilities.reduce((groups, vuln) => {
			const severity = vuln.severity;
			if (!groups[severity]) {
				groups[severity] = [];
			}
			groups[severity].push(vuln);
			return groups;
		}, {} as Record<string, VulnerabilityModel[]>);
	}

	static groupByType(
		vulnerabilities: VulnerabilityModel[]
	): Record<string, VulnerabilityModel[]> {
		return vulnerabilities.reduce((groups, vuln) => {
			const type = vuln.type;
			if (!groups[type]) {
				groups[type] = [];
			}
			groups[type].push(vuln);
			return groups;
		}, {} as Record<string, VulnerabilityModel[]>);
	}

	static sortBySeverity(
		vulnerabilities: VulnerabilityModel[]
	): VulnerabilityModel[] {
		const severityOrder = {
			critical: 0,
			high: 1,
			medium: 2,
			low: 3,
			informational: 4,
		};

		return vulnerabilities.sort((a, b) => {
			const severityDiff =
				severityOrder[a.severity] - severityOrder[b.severity];
			if (severityDiff !== 0) {
				return severityDiff;
			}
			// If same severity, sort by confidence (higher first)
			return b.confidence - a.confidence;
		});
	}

	toJSON() {
		return {
			id: this.id,
			audit_id: this.audit_id,
			type: this.type,
			severity: this.severity,
			title: this.title,
			description: this.description,
			location: this.location,
			recommendation: this.recommendation,
			confidence: this.confidence,
			source: this.source,
			created_at: this.created_at,
		};
	}
}
