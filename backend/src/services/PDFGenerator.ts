import puppeteer, { Browser, Page } from "puppeteer";
import * as fs from "fs-extra";
import * as path from "path";
import * as tmp from "tmp";

export interface PDFOptions {
	format?: "A4" | "Letter";
	margin?: {
		top?: string;
		right?: string;
		bottom?: string;
		left?: string;
	};
	displayHeaderFooter?: boolean;
	headerTemplate?: string;
	footerTemplate?: string;
	printBackground?: boolean;
}

export interface GeneratedPDF {
	buffer: Buffer;
	filePath?: string;
	metadata: {
		size: number;
		pages: number;
		generatedAt: Date;
	};
}

export class PDFGenerator {
	private static readonly DEFAULT_OPTIONS: PDFOptions = {
		format: "A4",
		margin: {
			top: "1in",
			right: "0.75in",
			bottom: "1in",
			left: "0.75in",
		},
		displayHeaderFooter: true,
		headerTemplate: `
			<div style="font-size: 10px; color: #666; width: 100%; text-align: center; margin-top: 0.5in;">
				Smart Contract Audit Report
			</div>
		`,
		footerTemplate: `
			<div style="font-size: 10px; color: #666; width: 100%; text-align: center; margin-bottom: 0.5in;">
				<span>Page <span class="pageNumber"></span> of <span class="totalPages"></span></span>
				<span style="float: right;">Generated by Audit Wolf</span>
			</div>
		`,
		printBackground: true,
	};

	/**
	 * Generate PDF from HTML content
	 */
	static async generatePDF(
		htmlContent: string,
		options: PDFOptions = {}
	): Promise<GeneratedPDF> {
		const mergedOptions = { ...this.DEFAULT_OPTIONS, ...options };

		let browser: Browser | null = null;
		let tempFile: tmp.FileResult | null = null;

		try {
			// Try to find Chrome executable
			let executablePath: string | undefined;

			// First try the local Chrome installation (go up one level from backend)
			const localChromePath = path.join(
				process.cwd(),
				"..",
				"chrome",
				"win64-142.0.7401.0",
				"chrome-win64",
				"chrome.exe"
			);

			if (await fs.pathExists(localChromePath)) {
				executablePath = localChromePath;
				console.log("Using local Chrome installation:", executablePath);
			} else {
				// Try Puppeteer's cached Chrome
				const cachedChromePath = path.join(
					require("os").homedir(),
					".cache",
					"puppeteer",
					"chrome",
					"win64-139.0.7258.154",
					"chrome-win64",
					"chrome.exe"
				);

				if (await fs.pathExists(cachedChromePath)) {
					executablePath = cachedChromePath;
					console.log("Using cached Chrome installation:", executablePath);
				} else {
					console.warn(
						"No Chrome installation found. Attempting to use system Chrome or install via Puppeteer."
					);
				}
			}

			browser = await puppeteer.launch({
				headless: true,
				executablePath,
				args: [
					"--no-sandbox",
					"--disable-setuid-sandbox",
					"--disable-dev-shm-usage",
					"--disable-gpu",
					"--disable-web-security",
					"--disable-features=VizDisplayCompositor",
				],
			});

			const page = await browser.newPage();

			// Set content and wait for it to load
			await page.setContent(htmlContent, {
				waitUntil: ["networkidle0", "domcontentloaded"],
			});

			// Generate PDF
			const pdfBuffer = await page.pdf({
				format: mergedOptions.format,
				margin: mergedOptions.margin,
				displayHeaderFooter: mergedOptions.displayHeaderFooter,
				headerTemplate: mergedOptions.headerTemplate,
				footerTemplate: mergedOptions.footerTemplate,
				printBackground: mergedOptions.printBackground,
			});

			// Create temporary file if needed
			tempFile = tmp.fileSync({ postfix: ".pdf", keep: false });
			await fs.writeFile(tempFile.name, pdfBuffer);

			// Get page count (approximate)
			const pageCount = await this.estimatePageCount(page);

			return {
				buffer: Buffer.from(pdfBuffer),
				filePath: tempFile.name,
				metadata: {
					size: pdfBuffer.length,
					pages: pageCount,
					generatedAt: new Date(),
				},
			};
		} catch (error) {
			// Clean up temp file on error
			if (tempFile) {
				try {
					fs.unlinkSync(tempFile.name);
				} catch (cleanupError) {
					console.warn("Failed to cleanup temp file:", cleanupError);
				}
			}

			throw new Error(
				`PDF generation failed: ${
					error instanceof Error ? error.message : "Unknown error"
				}`
			);
		} finally {
			// Clean up browser
			if (browser) {
				await browser.close();
			}
		}
	}

	/**
	 * Generate PDF and save to file
	 */
	static async generatePDFToFile(
		htmlContent: string,
		outputPath: string,
		options: PDFOptions = {}
	): Promise<GeneratedPDF> {
		const pdf = await this.generatePDF(htmlContent, options);

		// Ensure output directory exists
		await fs.ensureDir(path.dirname(outputPath));

		// Write to specified file
		await fs.writeFile(outputPath, pdf.buffer);

		return {
			...pdf,
			filePath: outputPath,
		};
	}

	/**
	 * Estimate page count from rendered page
	 */
	private static async estimatePageCount(page: Page): Promise<number> {
		try {
			// Get the height of the content
			const contentHeight = await page.evaluate(() => {
				// TypeScript doesn't know we're in a browser context, so we need to cast
				const doc = document as any;
				return Math.max(
					doc.body.scrollHeight,
					doc.body.offsetHeight,
					doc.documentElement.clientHeight,
					doc.documentElement.scrollHeight,
					doc.documentElement.offsetHeight
				);
			});

			// Estimate pages based on A4 height (approximately 1123px at 96 DPI)
			const pageHeight = 1123;
			return Math.ceil(contentHeight / pageHeight);
		} catch (error) {
			console.warn("Failed to estimate page count:", error);
			return 1;
		}
	}

	/**
	 * Validate HTML content before PDF generation
	 */
	static validateHTMLContent(htmlContent: string): {
		isValid: boolean;
		errors: string[];
	} {
		const errors: string[] = [];

		// Basic HTML validation
		if (!htmlContent.trim()) {
			errors.push("HTML content is empty");
		}

		if (!htmlContent.includes("<!DOCTYPE html>")) {
			errors.push("Missing DOCTYPE declaration");
		}

		if (!htmlContent.includes("<html")) {
			errors.push("Missing HTML tag");
		}

		if (!htmlContent.includes("<body")) {
			errors.push("Missing body tag");
		}

		// Check for balanced tags (simplified check)
		const openTags = (htmlContent.match(/<[^/!][^>]*[^/]>/g) || []).length;
		const closeTags = (htmlContent.match(/<\/[^>]*>/g) || []).length;
		const selfClosingTags = (htmlContent.match(/<[^>]*\/>/g) || []).length;

		// Rough validation - allow some flexibility for complex HTML
		const tagDifference = Math.abs(openTags - selfClosingTags - closeTags);
		if (tagDifference > 5) {
			// Allow some tolerance
			errors.push("Potentially unbalanced HTML tags detected");
		}

		return {
			isValid: errors.length === 0,
			errors,
		};
	}

	/**
	 * Get PDF generation options for different report types
	 */
	static getOptionsForReportType(
		reportType: "standard" | "executive" | "detailed"
	): PDFOptions {
		const baseOptions = { ...this.DEFAULT_OPTIONS };

		switch (reportType) {
			case "executive":
				return {
					...baseOptions,
					margin: {
						top: "1.5in",
						right: "1in",
						bottom: "1.5in",
						left: "1in",
					},
					headerTemplate: `
						<div style="font-size: 12px; color: #333; width: 100%; text-align: center; margin-top: 1in; font-weight: bold;">
							Executive Summary - Smart Contract Audit
						</div>
					`,
				};

			case "detailed":
				return {
					...baseOptions,
					margin: {
						top: "0.75in",
						right: "0.5in",
						bottom: "0.75in",
						left: "0.5in",
					},
					headerTemplate: `
						<div style="font-size: 9px; color: #666; width: 100%; text-align: left; margin-top: 0.25in;">
							<span style="float: left;">Detailed Audit Report</span>
							<span style="float: right;">Confidential</span>
						</div>
					`,
				};

			default:
				return baseOptions;
		}
	}

	/**
	 * Clean up temporary files
	 */
	static async cleanupTempFile(filePath: string): Promise<void> {
		try {
			if (await fs.pathExists(filePath)) {
				await fs.unlink(filePath);
			}
		} catch (error) {
			console.warn(`Failed to cleanup temp file ${filePath}:`, error);
		}
	}

	/**
	 * Get PDF metadata without generating the full PDF
	 */
	static async getPDFMetadata(htmlContent: string): Promise<{
		estimatedSize: number;
		estimatedPages: number;
	}> {
		// Rough estimates based on content length and complexity
		const contentLength = htmlContent.length;
		const estimatedSize = Math.max(contentLength * 0.1, 50000); // Minimum 50KB

		// Count page breaks and content sections
		const pageBreaks = (
			htmlContent.match(/page-break-after|class="page"/g) || []
		).length;
		const estimatedPages = Math.max(pageBreaks, 1);

		return {
			estimatedSize: Math.round(estimatedSize),
			estimatedPages,
		};
	}
}
